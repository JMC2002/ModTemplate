<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <LangVersion>14.0</LangVersion>
    <Nullable>enable</Nullable>
    <Deterministic>false</Deterministic>
    <!--启用通配符版本号-->
    <OutputType>Library</OutputType>
    <ModAuthor>JMC</ModAuthor>

    <!-- Mod名称，默认与项目名称相同 -->
    <ModName>$(MSBuildProjectName)</ModName>
    <!-- 自定义构建参数，默认不开启全量复制 -->
    <ForceCopy>false</ForceCopy>

    <!-- Steam库安装路径 -->
    <SteamAppPath>D:\SteamLibrary\steamapps\</SteamAppPath>

    <!-- 鸭科夫安装路径 -->
    <DuckovPath>$(SteamAppPath)common\Escape from Duckov</DuckovPath>

    <!-- Managed DLL目录 -->
    <DuckovManagedPath>$(DuckovPath)\Duckov_Data\Managed</DuckovManagedPath>

    <!-- Managed DLL目录 -->
    <DuckovModPath>$(DuckovPath)\Duckov_Data\Mods\</DuckovModPath>
    <!-- 项目根目录下的 Mods 文件夹 -->
    <ModLocalDir>$(ProjectDir)$(ModName)</ModLocalDir>
    <!-- 游戏 Mods 文件夹 -->
    <ModGameDir>$(DuckovModPath)$(ModName)</ModGameDir>
    <!-- 创意工坊文件夹 -->
    <SteamWorkShop>$(SteamAppPath)workshop\content\3167020\</SteamWorkShop>
    <!-- 存放版本信息的文件，提取形如Version = x.x.x的信息 -->
    <ModVersionFile>$(ProjectDir)Core\VersionInfo.cs</ModVersionFile>
    <Configurations>Debug;Release</Configurations>

  </PropertyGroup>


  <!-- 依赖引用 -->
  <ItemGroup>
    <Reference Include="$(DuckovManagedPath)\TeamSoda.*" />
    <Reference Include="$(DuckovManagedPath)\ItemStatsSystem.dll" />
    <Reference Include="$(DuckovManagedPath)\SodaLocalization.dll" />
    <Reference Include="JmcModLib">
      <HintPath>$(DuckovModPath)JmcModLib\JmcModLib.dll</HintPath>
    </Reference>
    <!--<Reference Include="JmcModLib">
      <HintPath>$(SteamWorkShop)3613297900\JmcModLib.dll</HintPath>
    </Reference>-->
    <Reference Include="$(DuckovManagedPath)\Unity*" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Lib.Harmony" Version="2.4.2" />
  </ItemGroup>

  <!-- 从版本文件提取版本信息并注入DLL -->
  <Target Name="ExtractVersion" BeforeTargets="BeforeBuild">
    <!-- 禁用默认生成 -->
    <PropertyGroup>
      <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
    </PropertyGroup>

    <!-- 读取文件 -->
    <ReadLinesFromFile File="$(ModVersionFile)">
      <Output TaskParameter="Lines" ItemName="VersionLinesRaw" />
    </ReadLinesFromFile>

    <!-- 把行合并为一个字符串 -->
    <PropertyGroup>
      <VersionFileContent>@(VersionLinesRaw, ' ')</VersionFileContent>
    </PropertyGroup>

    <!-- 用 Regex 提取版本号，加入 Trim() -->
    <PropertyGroup>
      <ExtractedVersion>$([System.Text.RegularExpressions.Regex]::Match('$(VersionFileContent)', 'Version\s*=\s*\"([0-9\.]+)\"').Groups[1].Value.Trim())</ExtractedVersion>
    </PropertyGroup>

    <!-- 提取 Name (查找 public const string Name = "xxx") -->
    <PropertyGroup>
      <ExtractedModName>$([System.Text.RegularExpressions.Regex]::Match('$(VersionFileContent)', 'Name\s*=\s*\"([^\"]+)\"').Groups[1].Value.Trim())</ExtractedModName>
    </PropertyGroup>

    <Message Text="📌 提取到的版本号: $(ExtractedVersion) | 名称: $(ExtractedModName)" Importance="High" />

    <Error Condition="'$(ExtractedVersion)' == ''" Text="❌ 无法从 VersionInfo.cs 中提取版本号。" />
    <Error Condition="'$(ExtractedModName)' == ''" Text="❌ 无法从 VersionInfo.cs 中提取名称。" />

    <!-- ⭐ 用 Property 拼出全部代码，不使用 ItemGroup -->
    <PropertyGroup>
      <AutoAssemblyInfoText>
[assembly: System.Reflection.AssemblyVersion("$(ExtractedVersion).*")]
[assembly: System.Reflection.AssemblyFileVersion("$(ExtractedVersion).0")]
[assembly: System.Reflection.AssemblyInformationalVersion("$(ExtractedVersion)")]

[assembly: System.Reflection.AssemblyTitle("Duckov mod $(ModName) by $(ModAuthor)")]
[assembly: System.Reflection.AssemblyDescription("Duckov mod $(ModName) by $(ModAuthor)")]
[assembly: System.Reflection.AssemblyProduct("$(ModName)")]
[assembly: System.Reflection.AssemblyCompany("$(ModAuthor)")]
[assembly: System.Reflection.AssemblyMetadata("ModAuthor", "$(ModAuthor)")]
[assembly: System.Reflection.AssemblyMetadata("ModName", "$(ModName)")]
      </AutoAssemblyInfoText>
    </PropertyGroup>

    <!-- ⭐ 一次性输出，不会被 MSBuild 自动加换行或缩进 -->
    <WriteLinesToFile File="$(IntermediateOutputPath)AutoVersionInfo.g.cs" Lines="$(AutoAssemblyInfoText)" Overwrite="true" />

    <ItemGroup>
      <Compile Include="$(IntermediateOutputPath)AutoVersionInfo.g.cs" />
    </ItemGroup>

  </Target>




  <!-- 构建后自动复制 DLL -->
  <Target Name="PostBuild" AfterTargets="Build">
    <!-- 确保目标文件夹存在 -->
    <MakeDir Directories="$(ModLocalDir)" />
    <MakeDir Directories="$(ModGameDir)" />

    <!-- 复制刚编译的 DLL -->
    <Copy SourceFiles="$(TargetPath)" DestinationFolder="$(ModLocalDir)" />

    <!-- 使用 PowerShell 修改 info.ini -->
    <Message Text="📝 正在更新 info.ini 元数据..." Importance="High" />
    <Exec Command="powershell -NoProfile -ExecutionPolicy Bypass -Command ^&#xD;&#xA;      $path = '$(ModLocalDir)\info.ini'; ^&#xD;&#xA;      $name = '$(ExtractedModName)'; ^&#xD;&#xA;      $ver = '$(ExtractedVersion)'; ^&#xD;&#xA;      if (Test-Path $path) { ^&#xD;&#xA;          $lines = [System.Collections.Generic.List[string]](Get-Content $path -Encoding UTF8); ^&#xD;&#xA;          $hasName = $false; ^&#xD;&#xA;          $hasVer = $false; ^&#xD;&#xA;          for($i=0; $i -lt $lines.Count; $i++) { ^&#xD;&#xA;              if($lines[$i] -match '^^\s*name\s*=') { ^&#xD;&#xA;                  $lines[$i] = 'name = ' + $name; ^&#xD;&#xA;                  $hasName = $true; ^&#xD;&#xA;              } ^&#xD;&#xA;              elseif($lines[$i] -match '^^\s*version\s*=') { ^&#xD;&#xA;                  $lines[$i] = 'version = ' + $ver; ^&#xD;&#xA;                  $hasVer = $true; ^&#xD;&#xA;              } ^&#xD;&#xA;          } ^&#xD;&#xA;          if(-not $hasName) { $lines.Insert(0, 'name = ' + $name); } ^&#xD;&#xA;          if(-not $hasVer) { $lines.Add('version = ' + $ver); } ^&#xD;&#xA;          Set-Content -Path $path -Value $lines -Encoding UTF8; ^&#xD;&#xA;          Write-Host '   -- info.ini 更新完成'; ^&#xD;&#xA;      } else { ^&#xD;&#xA;          Write-Warning '   -- 未找到 info.ini (跳过更新)'; ^&#xD;&#xA;      }" />

    <!-- 根据 ForceCopy 决定 robocopy 参数 -->
    <PropertyGroup>
      <!-- 如果 ForceCopy 为 true，不使用 /XO /XN /XC；否则增量复制 -->
      <RoboArgs Condition="'$(ForceCopy)' == 'true'">/E /R:0 /W:0 /XD bin obj</RoboArgs>
      <RoboArgs Condition="'$(ForceCopy)' != 'true'">/E /XO /XC /R:0 /W:0 /XD bin obj</RoboArgs>
    </PropertyGroup>

    <Message Text="开始复制 mod 文件..." Importance="High" />
    <Message Text="🔧 ForceCopy = $(ForceCopy)" Importance="High" />
    <Exec Command="robocopy &quot;$(ModLocalDir)&quot; &quot;$(ModGameDir)&quot; $(RoboArgs)" ConsoleToMSBuild="true" IgnoreExitCode="true" StandardOutputImportance="High">
      <Output TaskParameter="ExitCode" PropertyName="RoboExitCode" />
    </Exec>

    <!--  处理 robocopy 的返回码，容忍 0–3 -->
    <Message Text="Robocopy 退出代码: $(RoboExitCode)" Importance="High" />
    <Error Condition="$(RoboExitCode) &gt; 3" Text="❌ Robocopy 复制失败（代码 $(RoboExitCode)）！" />

    <!--  成功提示 -->
    <Message Condition="$(RoboExitCode) == 0" Text="✅ 没有需要更新的文件，一切都是最新的。" Importance="High" />
    <Message Condition="$(RoboExitCode) == 1" Text="📁 已复制新的文件。" Importance="High" />
    <Message Condition="$(RoboExitCode) == 2" Text="📝 文件属性已更新。" Importance="High" />
    <Message Condition="$(RoboExitCode) == 3" Text="🔄 文件和属性都有更新。" Importance="High" />
  </Target>

  <!-- ✅ 构建成功后询问是否启动游戏 -->
  <Target Name="AskToLaunchGame" AfterTargets="PostBuild">
    <PropertyGroup>
      <GameExe>$(DuckovPath)\Duckov.exe</GameExe>
    </PropertyGroup>

    <Exec Command="powershell -NoProfile -ExecutionPolicy Bypass -Command ^&#xD;&#xA;        Add-Type -AssemblyName PresentationFramework; ^&#xD;&#xA;        $res = [System.Windows.MessageBox]::Show('是否现在启动 逃离鸭科夫？','启动游戏','YesNo','Question'); ^&#xD;&#xA;        if ($res -eq 'Yes') { Start-Process '&quot;$(GameExe)&quot;' }" IgnoreExitCode="true" />
  </Target>

</Project>
